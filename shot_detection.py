# -*- coding: utf-8 -*-
"""Video-Shot-Detection-3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1aNZ9FdSZffCTWgmPD3_MxZD258Qrd36Z
"""

import shutil
import os
import sys
import cv2
import numpy as np
from typing import List

class ShotSegmentation:
    def __init__(self, threshold: float = 0.3, min_scene_len: int = 10):
        self.threshold = threshold
        self.min_scene_len = min_scene_len

# Histogram diff {{{
    def histogram_diff(self, frame1: np.ndarray, frame2: np.ndarray) -> float:
        img1 = cv2.cvtColor(frame1, cv2.COLOR_BGR2HSV)
        hist1 = cv2.calcHist([img1], [0, 1], None, [180, 256], [0, 180, 0, 256])

        img2 = cv2.cvtColor(frame2, cv2.COLOR_BGR2HSV)
        hist2 = cv2.calcHist([img2], [0, 1], None, [180, 256], [0, 180, 0, 256])

        cv2.normalize(hist1, hist1)
        cv2.normalize(hist2, hist2)

        return cv2.compareHist(hist1, hist2, cv2.HISTCMP_BHATTACHARYYA)# }}}
# Segment Shots {{{ 
    def segment_shots(self, video_path: str) -> List[int]:
        cap = cv2.VideoCapture(video_path)
        if not cap.isOpened():
            raise ValueError(f"Could not open video file: {video_path}")

        shot_frames = []
        prev_frame = None
        frame_count = 0
        last_shot_frame = -self.min_scene_len

        while True:
            for i in range(20):
                ret, frame = cap.read()
            print(frame_count*20)
            if not ret:
                break
            if prev_frame is not None:
                diff = self.histogram_diff(prev_frame, frame)
                if (diff > self.threshold and
                    frame_count - last_shot_frame >= self.min_scene_len):
                    shot_frames.append(frame_count)
                    last_shot_frame = frame_count
            prev_frame = frame
            frame_count += 1

        cap.release()

        return shot_frames# }}}
# {{{ Extract frame ranges
    def extract_frame_ranges(self, video_path, frame_ranges, output_dir=None, output_prefix='segment'):
        if output_dir is None:
            output_dir = os.path.join(os.path.dirname(video_path), 'extracted_segments')
        os.makedirs(output_dir, exist_ok=True)

        cap = cv2.VideoCapture(video_path)

        total_frames = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))
        fps = cap.get(cv2.CAP_PROP_FPS)
        width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
        height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))

        processed_ranges = frame_ranges.copy()
        if processed_ranges[-1] is None:
            processed_ranges[-1] = total_frames

        sorted_ranges = sorted(processed_ranges)

        output_videos = []

        for i in range(len(sorted_ranges) - 1):
            start_frame = sorted_ranges[i]
            end_frame = sorted_ranges[i+1]

            if start_frame >= end_frame:
                print(f"Skipping invalid range: {start_frame} to {end_frame}")
                continue

            output_filename = f'shot_{output_prefix}_{i:06d}.mp4'
            output_path = os.path.join(output_dir, output_filename)

            fourcc = cv2.VideoWriter_fourcc(*'mp4v')
            out = cv2.VideoWriter(output_path, fourcc, fps, (width, height))

            cap.set(cv2.CAP_PROP_POS_FRAMES, start_frame)

            current_frame = start_frame
            while current_frame < end_frame:
                ret, frame = cap.read()
                if not ret:
                    break
                out.write(frame)
                current_frame += 1

            out.release()
            output_videos.append(output_path)
        cap.release()

        return output_videos# }}}

    def __call__(self, video_path, export_path):
        shot_frames = self.segment_shots(video_path)
        extracted_videos = self.extract_frame_ranges(video_path, shot_frames, output_dir=export_path)
        return extracted_videos

def main(video_path="./movie.mp4", export_path="./extracted_segments/"):
    segmenter = ShotSegmentation(threshold=0.3, min_scene_len=10)
    segmenter(video_path, export_path)

if __name__ == "__main__":
    main(sys.argv[1], sys.argv[2] if len(sys.argv)>2 else None)
